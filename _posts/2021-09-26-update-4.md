---
title: Ideas are worthless, but semaphores are not - part four.
categories: [drafs]
tags: [Memoir]
layout: post


---

Mountains, semaphores and ideas.

<img src="https://i.imgur.com/sIQcw8s.jpg" height="400">

<p style="text-align:center"> Kundadri, Shimoga, 2019</p>

## Recap

For those new here, I aspire to write about what is happening with me on at least a weekly basis. To quote my older post

> I hope I keep this up and eventually I can publish my future memoir of my wildly successful life with this a reference.

In that spirit, I _had_ decided to rename this series to "My memoir", and then soon later declared that I don't like the name. I have now decided that I don't want to restrict it to any name. Every chapter will have it's own title followed by the chapter number. Let's see how my titles get progressively worse. Enough with the rambling, read the rest of my "memoir" [here](https://advait.live/tags/#Memoir). 

Apart from this, all my chapters end with "Notes on the [epigraph](https://en.wikipedia.org/wiki/Epigraph_(literature))" where I give more context on the photograph in my frontmatter.



### An elegant solution.

I recently got to use a very elegant technique to keep track and limit the number of concurrent connections to a websocket server I am building at work. Luckily for me, I have written the server in Go which has excellent primitves for dealing with synchronisation and concurrency. 

The problem statement was quite simple

> Keep track of the number of concurrent websocket connections to the server. 

For anyone who is new to Go, every time a new connection is made to the server, a new thread (goroutine) is spawned to handle the connection. Knowing this, the best way to keep track of the concurrency was using a semaphore to control access to the handler function for the websocket endpoint. Adapting the method I found [here](https://medium.com/@deckarep/gos-extended-concurrency-semaphores-part-1-5eeabfa351ce), I was able to keep track of my concurrent connections by simply using a buffered go channel as a semaphore.

```go
func Handler(w http.ResponseWriter, r *http.Request) {

	// As soon as we get a new socket connection, add it the counting semaphore buffer.
	semaphore <- 1

	// Right before we leave this function, remove it from the semaphore buffer.
	defer func() { <-semaphore }()

	....
}
```



This way

